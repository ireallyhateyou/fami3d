<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>fami3D</title>
  <script src="https://unpkg.com/jsnes/dist/jsnes.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
  <style>
    body { background: #222; color: #fff; font-family: sans-serif; }
    #nes-canvas { background: #000; image-rendering: pixelated; }
  </style>
</head>
<body>
  <input type="file" id="romfile" accept=".nes" style="position:relative; z-index:1; pointer-events:auto;" />
  <div id="canvas-row" style="display:flex; gap:12px; align-items:flex-start; margin-bottom:12px;">
    <div style="display:flex; flex-direction:column; align-items:center;">
      <canvas id="bg-canvas" width="256" height="240" style="border:1px solid #444; background:#000;"></canvas>
      <span style="color:#aaa; font-size:13px; margin-top:4px;">Background</span>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center;">
      <canvas id="sprite-canvas" width="256" height="240" style="border:1px solid #444; background:transparent;"></canvas>
      <span style="color:#aaa; font-size:13px; margin-top:4px;">Sprites</span>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center;">
      <canvas id="nes-canvas" width="256" height="240" style="border:1px solid #444;"></canvas>
      <span style="color:#aaa; font-size:13px; margin-top:4px;">NES Output</span>
    </div>
  </div>
  <button id="startBtn" disabled style="position:relative; z-index:1; pointer-events:auto;">Start</button>
  <script>
    const canvas = document.getElementById('nes-canvas');
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, 256, 240);

    let nes = null;
    let animationId = null;
    let romData = null;

    // File input
    document.getElementById('romfile').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(event) {
        romData = event.target.result;
        document.getElementById('startBtn').disabled = false;
      };
      reader.readAsBinaryString(file);
    });

    // FirebrandX NTSC NES palette (64 RGB triplets)
    const fbxPalette = [
      [124,124,124],[0,0,252],[0,0,188],[68,40,188],[148,0,132],[168,0,32],[168,16,0],[136,20,0],
      [80,48,0],[0,120,0],[0,104,0],[0,88,0],[0,64,88],[0,0,0],[0,0,0],[0,0,0],
      [188,188,188],[0,120,248],[0,88,248],[104,68,252],[216,0,204],[228,0,88],[248,56,0],[228,92,16],
      [172,124,0],[0,184,0],[0,168,0],[0,168,68],[0,136,136],[0,0,0],[0,0,0],[0,0,0],
      [248,248,248],[60,188,252],[104,136,252],[152,120,248],[248,120,248],[248,88,152],[248,120,88],[252,160,68],
      [248,184,0],[184,248,24],[88,216,84],[88,248,152],[0,232,216],[120,120,120],[0,0,0],[0,0,0],
      [252,252,252],[164,228,252],[184,184,248],[216,184,248],[248,184,248],[248,164,192],[240,208,176],[252,224,168],
      [248,216,120],[216,248,120],[184,248,184],[184,248,216],[0,252,252],[248,216,248],[0,0,0],[0,0,0]
    ];

    // Start button
    document.getElementById('startBtn').onclick = function() {
      if (!romData) return;
      if (animationId) cancelAnimationFrame(animationId);
      nes = new jsnes.NES({
        palette: fbxPalette,
        onFrame: function(buffer) {
          // buffer is Uint32Array (256*240), ARGB (JSNES default)
          for (let i = 0; i < 256 * 240; i++) {
            const c = buffer[i];
            imageData.data[i * 4 + 0] = c & 0xFF; // R
            imageData.data[i * 4 + 1] = (c >> 8) & 0xFF;  // G
            imageData.data[i * 4 + 2] = (c >> 16) & 0xFF;         // B
            imageData.data[i * 4 + 3] = 0xFF;             // A
          }
          ctx.putImageData(imageData, 0, 0);
          drawBackgroundLayer();
          drawSpriteLayer();
        }
      });
      nes.loadROM(romData);
      window.nes = nes; // Expose for console inspection
      console.dir(nes);
      let lastTime = 0;
      function frameLoop(now) {
        if (!lastTime || now - lastTime >= 1000 / 60) {
          nes.frame();
          lastTime = now;
        }
        animationId = requestAnimationFrame(frameLoop);
      }
      requestAnimationFrame(frameLoop);
    };

    const bgCanvas = document.getElementById('bg-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const spriteCanvas = document.getElementById('sprite-canvas');
    const spriteCtx = spriteCanvas.getContext('2d');

    // Swap R and B channels for CSS color
    function swapRB(color) {
      color = color & 0xFFFFFF;
      const r = (color >> 16) & 0xFF;
      const g = (color >> 8) & 0xFF;
      const b = color & 0xFF;
      return (b << 16) | (g << 8) | r;
    }

    function drawBackgroundLayer() {
      if (!window.nes || !window.nes.ppu) return;
      const ppu = window.nes.ppu;
      bgCtx.clearRect(0, 0, 256, 240);
      // Draw each tile using pattern table and correct NES palette logic
      for (let y=0; y<30; y++) for (let x=0; x<32; x++) {
        const ntAddr = 0x2000 + y*32 + x;
        const tileIdx = ppu.vramMem ? ppu.vramMem[ntAddr] : 0;
        // Attribute table is at 0x23C0 + (nametable select) * 0x400
        const ntBase = 0x2000 + ((ntAddr - 0x2000) & 0x0C00);
        const attrTableAddr = ntBase + 0x3C0 + ((y >> 2) * 8) + (x >> 2);
        let attrByte = 0;
        if (ppu.vramMem && typeof ppu.vramMem[attrTableAddr] === 'number') {
          attrByte = ppu.vramMem[attrTableAddr];
        }
        // Which quadrant of the attribute byte?
        const shift = ((y & 2) ? 4 : 0) + ((x & 2) ? 2 : 0);
        const palIdx = (attrByte >> shift) & 0x3;
        // Each tile is 16 bytes in pattern table
        const ptAddr = tileIdx * 16;
        for (let row=0; row<8; row++) {
          const plane0 = ppu.vramMem ? ppu.vramMem[ptAddr + row] : 0;
          const plane1 = ppu.vramMem ? ppu.vramMem[ptAddr + row + 8] : 0;
          for (let col=0; col<8; col++) {
            const bit0 = (plane0 >> (7-col)) & 1;
            const bit1 = (plane1 >> (7-col)) & 1;
            const colorIdx = (bit1 << 1) | bit0;
            // NES: colorIdx==0 is always universal BG color (palette index 0)
            let paletteBase = palIdx * 4;
            let color = 0x888888;
            if (ppu.imgPalette && Array.isArray(ppu.imgPalette)) {
              if (colorIdx === 0) {
                // Universal BG color
                color = ppu.imgPalette[0];
              } else {
                color = ppu.imgPalette[paletteBase + colorIdx];
              }
            }
            bgCtx.fillStyle = `#${swapRB(color).toString(16).padStart(6,'0')}`;
            bgCtx.fillRect(x*8+col, y*8+row, 1, 1);
          }
        }
      }
    }
    function drawSpriteLayer() {
      if (!window.nes || !window.nes.ppu) return;
      const ppu = window.nes.ppu;
      spriteCtx.clearRect(0, 0, 256, 240);
      // Draw each sprite using pattern table and correct NES palette logic
      for (let i=0; i<64; i++) {
        const sx = ppu.sprX ? ppu.sprX[i] : 0;
        const sy = ppu.sprY ? ppu.sprY[i] : 0;
        const tileIdx = ppu.sprTile ? ppu.sprTile[i] : 0;
        // Sprite palette index is lower 2 bits of attribute byte (OAM)
        let palIdx = 0;
        if (ppu.spriteMem && typeof ppu.spriteMem[i*4+2] === 'number') {
          palIdx = ppu.spriteMem[i*4+2] & 0x3;
        }
        // Each tile is 16 bytes in pattern table
        const ptAddr = tileIdx * 16;
        for (let row=0; row<8; row++) {
          const plane0 = ppu.vramMem ? ppu.vramMem[ptAddr + row] : 0;
          const plane1 = ppu.vramMem ? ppu.vramMem[ptAddr + row + 8] : 0;
          for (let col=0; col<8; col++) {
            const bit0 = (plane0 >> (7-col)) & 1;
            const bit1 = (plane1 >> (7-col)) & 1;
            const colorIdx = (bit1 << 1) | bit0;
            // NES: colorIdx==0 is transparent for sprites
            if (colorIdx === 0) continue;
            let paletteBase = 16 + palIdx * 4;
            let color = 0x888888;
            if (ppu.imgPalette && Array.isArray(ppu.imgPalette)) {
              color = ppu.imgPalette[paletteBase + colorIdx];
            }
            spriteCtx.fillStyle = `#${swapRB(color).toString(16).padStart(6,'0')}`;
            spriteCtx.fillRect(sx+col, sy+row, 1, 1);
          }
        }
      }
    }
  </script>
</body>
</html>
